# go的垃圾回收机制

go的垃圾回收机制采用**三色标记法**和**混合写屏障**技术


## 常见的垃圾回收算法
### 引用计数 
**引用计数**通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象，这种算法在内存比较紧张和实时性比较高的系统中使用比较广泛，如php，Python等。

优点：方式简单，回收速度快
缺点：
1. 不能很好的处理循环引用（如a.b=b;b.a=a）
2. 需要额外的空间存放计数
3. 频繁更新引用计数，降低性能


### 追踪式回收
追踪式算法（可达性分析）的核心思想是判断一个对象是否可达，如果这个对象不可达就可以被GC回收了。

如果判断一个对象是否可达
1. 第一步，从根节点开始找出所有全局变量和当前函数栈里的变量标记为可达
2. 第二步，从已标记的对象开始，进一步标记它可以访问的对象，一次类推。当追踪结束时，没有被打上标记的对象就被判断不可触达
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42f9e9925ae473eb52ed795f8da5e35~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

优点: 
1. 解决循环引用的问题
2. 占用的空间少

缺点：
1. 算法标记是需要暂停程序，即STW（stop the world），否则其他线程可能会修改对象的状态，导致回收不该回收的对象

## 三色标记法
三色标记法将程序中的对象分成黑、白、灰三类

1. 白色对象 - 潜在的垃圾，表示还未搜索到的对象，其内存可能会被垃圾收集器回收；
2. 黑色对象 - 活跃的对象，表示搜索完成的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象
3. 灰色对象 - 活跃的对象，表示正在搜索还未搜索完的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

具体过程：
- 初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
回收所有白色对象（垃圾）

## 混合写屏障（插入写屏障+删除写屏障）

### 插入写屏障
当一个对象B引用另一个对象A时，将被引用的对象A标记为灰色，以此满足强三色不变性

### 删除写屏障
在灰色对象删除对白色对象的引用时，将白色对象标记为灰色，其实就是保存旧的引用关系，这叫STAB（snapshot-at-the-beginning），以此满足弱三色不变性

1.18版本之前采用插入写屏障，之后开始组合插入写屏障和删除写屏障构成了混合写屏障；该写屏障会将覆盖的对象标记成灰色(删除写屏障)并在当前栈没有扫描时将新对象也标记成灰色(插入写屏障)：


# gc触发时机
当满足触发垃圾收集的基本条件：允许垃圾收集、程序没有崩溃并且没有处于垃圾循环；

三种不同的触发方式：
1. **内存分配量达到阈值触发**：默认配置会在堆内存达到上一次垃圾收集的2倍时，触发新一轮的垃圾收集，可以通过环境变量`GOGC`调整，在默认情况下他的值为100，即增长100%的堆内存才会触发GC
2. **定期触发**：如果一直达不到内存大小的阈值，则会在一段时间内触发GC（默认2分钟）
3. **主动触发**：调用runtime.GC() 强制触发

> [一文搞懂go gc垃圾回收原理](https://juejin.cn/post/7111515970669117447)