# go的垃圾回收机制

go的垃圾回收机制采用**三色标记法**和**混合写屏障**技术

## 三色标记法：

将对象标记为白色，灰色或黑色。

白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。

标记开始时，先将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。最后的白色集合对象就是需要清理的对象。

>这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了**写屏障**技术，当对象新增或者更新会将其着色为灰色

### 一次完整的GC分为四个阶段：

- 准备标记（需要STW），开启写屏障。
- 开始标记
- 标记结束（STW），关闭写屏障
- 清理（并发）

基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。

### 混合写屏障分为以下四步：

- GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；
- GC期间，任何栈上创建的新对象均为黑色
- 被删除引用的对象标记为灰色
- 被添加引用的对象标记为灰色

总而言之就是确保黑色对象不能引用白色对象，这个改进直接使得GC时间从 2s降低到2us。


## 常见的垃圾回收算法
### 引用计数 
**引用计数**通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象，这种算法在内存比较紧张和实时性比较高的系统中使用比较广泛，如php，Python等。

优点：方式简单，回收速度快
缺点：
1. 不能很好的处理循环引用（如a.b=b;b.a=a）
2. 需要额外的空间存放计数
3. 频繁更新引用计数，降低性能


### 追踪式回收
追踪式算法（可达性分析）的核心思想是判断一个对象是否可达，如果这个对象不可达就可以被GC回收了。

如果判断一个对象是否可达
1. 第一步，从根节点开始找出所有全局变量和当前函数栈里的变量标记为可达
2. 第二步，从已标记的对象开始，进一步标记它可以访问的对象，一次类推。当追踪结束时，没有被打上标记的对象就被判断不可触达
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42f9e9925ae473eb52ed795f8da5e35~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

优点: 
1. 解决循环引用的问题
2. 占用的空间少

缺点：
1. 算法标记是需要暂停程序，即STW（stop the world），否则其他线程可能会修改对象的状态，导致回收不该回收的对象

### 三色标记法
三色标记法将程序中的对象分成黑、白、灰三类

1. 白色对象 - 潜在的垃圾，表示还未搜索到的对象，其内存可能会被垃圾收集器回收；
2. 黑色对象 - 活跃的对象，表示搜索完成的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象
3. 灰色对象 - 活跃的对象，表示正在搜索还未搜索完的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

具体过程：
- 初始状态下所有对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
回收所有白色对象（垃圾）

## 混合写屏障（插入写屏障+删除写屏障）

### 插入写屏障
当一个对象B引用另一个对象A时，将被引用的对象A标记为灰色，以此满足强三色不变性

### 删除写屏障
在灰色对象删除对白色对象的引用时，将白色对象标记为灰色，其实就是保存旧的引用关系，这叫STAB（snapshot-at-the-beginning），以此满足弱三色不变性

1.18版本之前采用插入写屏障，之后开始组合插入写屏障和删除写屏障构成了混合写屏障；该写屏障会将覆盖的对象标记成灰色(删除写屏障)并在当前栈没有扫描时将新对象也标记成灰色(插入写屏障)

GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；
GC期间，任何栈上创建的新对象均为黑色
被删除引用的对象标记为灰色
被添加引用的对象标记为灰色


# gc触发时机 三种不同的触发方式

### 内存分配量达到阈值触发
默认配置会在堆内存达到上一次垃圾收集的2倍时，触发新一轮的垃圾收集，可以通过环境变量`GOGC`调整，在默认情况下他的值为100，即增长100%的堆内存才会触发GC

### 定期触发
如果一直达不到内存大小的阈值，则会在一段时间内触发GC（默认2分钟）

### 主动触发
调用runtime.GC() 强制触发

> [一文搞懂go gc垃圾回收原理](https://juejin.cn/post/7111515970669117447)