# go内存逃逸

## 什么是内存逃逸

在程序中，每个函数快都有自己的内存区域用来存自己的函数名、局部变量（内存占用少）、返回地址、返回值之类的数据，这块内存区域有特定的结构和寻址方式，寻址十分迅速，开销少。这块内存区地址称为栈。栈是线程级别的，大小在创建时已经确定，当变量太大的时候，会“逃逸”到堆上，这种现象称为内存逃逸。**简单来说局部变量，通过堆分配和回收，就叫内存逃逸**

## 内存逃逸的危害

堆事一块没有特定结构，也没有固定大小的内存区域，可以根据需要进行调整。分配到堆中的变量主要是以下几种情况
1. **全局变量**，
2. 内存占用比较大的局部变量，
3. **函数调用结束后不能立即回收的局部变量**

变量在堆上的分配和回收都比在栈上开销大的多。对于go，会增加gc压力，同时也容易造成内存碎片。

## 逃逸分析的基本原则
编译器会根据变量是否被外部引用来决定是否逃逸
1. 如果函数外部没有引用，则优先放在栈中；
2. 如果函数外部存在引用，则必定放在堆中；
3. 如果栈上放不下，则必定放在堆上

## 逃逸场景
### 指针逃逸
go可以返回局部变量指针，这种情况，函数虽然退出，但是因为指针的存在，对象的内存不能回收，必须分配到堆上
### 栈空间不足逃逸
因为栈空间大小是固定的，局部变量过大无法容纳也会逃逸到堆上
### 动态类型逃逸
空接口`interface{}`可以表示任意类型，如果函数参数为`interface{}`,编译期间很难确定其参数的具体类型，也会发生逃逸
### 闭包引用对象逃逸

## 内存逃逸的时机
1. 向 `channel` 发送指针数据。因为在编译时，不知道channel的数据会被哪个goroutine接收，因此编译器没法知道变量什么时候才会被释放，因为只能放入堆中
```go
package main

func main() {
    ch := make(chan int, 1)
    x := 5
    ch <- x // x不发生内存逃逸，因为只是复制的值，返回返回时x就可以被回收
    
    ch1 := make(chan *int, 1)
    y := 5
    py := &y
    ch1 <- py //y逃逸，因为y地址传入了chan中，编译时无法确定什么时候会被接收，所以无法在函数返回时回收y
}
```

2. 局部变量在函数调用结束后还被其他地方使用，比如函数返回局部变量的指针，或闭包中引用包外的值。因为变量的生命周期可能会超过函数调用的周期，因为只能放入堆中
```go
package main

func Foo() func() {
    x := 5
    return func() {
        x += 1;
    }
}

func main() {
    inner := Foo()
    inner()
}
```

4. 在slice或map中存储指针，比如[]*string，其后面的数组可能是在栈上分配的，但其引用的值还是在堆上
5. 切片扩容后长度太大，导致栈空间不足，逃逸到堆上
6. 在interface类型上调用方法。在interface类型上调用方法时会把interface变量使用堆分配，因为方法的真正实现只有运行时知道

## 规避内存逃逸的办法
- 对与小型的数据，使用传值而不是指针
- 避免使用长度比固定的slice，在编译期无法确定切片长度，会逃逸到堆上
- interface调用方法会发生内存逃逸，热点代码片段中谨慎使用

## 逃逸分析
通过`go build`编译编译命令的参数 `-gcflags=-m` 可以查看编译过程中的逃逸分析

> [go的逃逸场景有哪些](https://cloud.tencent.com/developer/article/1877008)