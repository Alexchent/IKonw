# mysql 索引优化

## 三大原则
### 高散列度原则
通过索引查询得到的样本精确越好，比如状态字段就不合适作为索引

### 最小空间原则
因为B+tree的特性，key越小，根节点和分支节点存储的key越多，树的高度越低，IO次数越少，查询效率也就越高。因此索引要限制key的长度

### 最左前缀原则
联合索引的触发条件是查询条件中必须包含一个字段

特别需要注意的，范围查询会导致后面的key不触发索引

比如 （a,b,c）作为联合索引
`select a,b,c from t where a=1 and b>1 and c=1`
这条sql，只有a，b会触发索引

## 导致无法触发索引的情况
### 1. 数据类型不一致

普通where查询中的不一致
- 当操作符左右两边的**数据类型不一致**时，会发生**隐式转换**。
- 当 where 查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。
- 当 where 查询操作符**左边为字符类型**时发生了隐式转换，那么会**导致索引失效**，造成全表扫描效率极低。
- 字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。

所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描

join查询中，如果关联字段的数据类型不一致会导致索引失效。比如一个用int类型，一个用varchar类型

优化方案:
1. 如果表数据量允许的情况下，可以直接修改变字段类型。
2. 需要在查询时做强制类型转化，可以用`cast`或`convert`函数将类型严格的一方转换为类型松散的一方的类型，这样也能避免精度丢失。比如，可以将数值型向字符串类型转，反过来则会有问题

### 2. in 查询 
如果查询的数据比较分散也会出现索引失效

### 3. 尽可能避免使用 != 和 <>

### 4. 避免在where子句中出现null判断，建表时就设置为非空

### 5. 避免用or作为连接条件，用union代替

### 6. join代替子查

### 7. 如果where子句中使用参数，也会导致全表扫描
因为sql只有运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时，它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
select id from t where num=@num
可以强制查询使用索引：
select id from t with（index（索引名）） where num=@num

### 8. 尽量避免在where子句中对字段进行表达式操作或函数操作
如：
select id from where num/2=100
改成：
select id from where num=100*2