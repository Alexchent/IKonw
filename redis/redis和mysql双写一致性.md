# redis和mysql双写一致性

## 三个经典的缓存模式
- Cache-Aside Pattern 旁路缓存模式
- Read-through/Write-through 读写穿透模式
- Write behind 异步写入模式

### Cache-Aside （旁路缓存）
**旁路缓存模式** 是最常用的缓存模式

写请求，会先更新数据库，在删除缓存
读请求，会先从缓存中读，存在则返回，不存在则从数据库获取，在写入缓存，后返回

### Read-through/Write-through （读写穿透）
**读写穿透模式**，是在旁路缓存模式的基础上加上一层 **cache provider**

![](assets/read-through.awebp)

Write-Through模式下，当发生写请求时，也是由缓存抽象层完成数据源和缓存数据的更新,流程如下:
![](assets/write-through.awebp)

### write behind (异步缓存写入)

异步缓存写入，也是有**cache privoder**负责缓存和数据库的读写，不同的是，write behind只更新缓存，不直接更新数据库，通过批量异步的方式更新数据库。
![](assets/write-behind.awebp)

## 如果保证双写一致性
- 延迟双删
- 删除重试
- 读取binlog异步删除缓存

导致不一致的情况
1. 写请求，更新数据库前，一个并发的读请求，读取缓存，此时恰好缓存过期，去数据库读取数据（旧），此时恰好由写请求，数据库更新，删除缓存后，而次数请求的数据写入缓存，此时缓存内的数据就是脏数据
2. 写请求删除缓存失败

解决方案：
### 延迟双删
写请求，先删除缓存，在更新数据库，最后延迟1s再次删除缓存

> 延迟时间 = 读请求的耗时+100ms，以保证读请求结束，可以删除读请求带来的脏数据

### 删除重试
1. 写请求更新数据库
2. 删除缓存失败
3. 把删除失败的key放入队列
4. 消费队列异步删除缓存

### 读取binlog异步删除缓存
重试删除机制，会侵入原业务代码，还可以通过监控数据库的biglog来异步删除缓存

以mysql为例 可以使用阿里的**canal**将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性

### 人工介入
管理后台增加一个刷新缓存的功能按钮，在redis发生异常恢复后，人工处理