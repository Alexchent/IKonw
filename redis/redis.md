# reids
## 实现分布式锁

1. redlock
2. [redission](./redis分布式锁redission.md)

## 持久化机制 
redis有两种持久化方式：RDB和AOF
1. RDB：按一定的频率fork子进程进行快照，生成二进制的rdb文件
2. AOF：将写命令记录到AOF日志文件中（更新频率由三种选择：allways、everysec和no)。
可读性强，但文件更大，可以设置自动重写，生成新的aof文件替换旧的解决

6.0之前的版本，如果同时开始同种持久化方式，redis会优先采用aof进行恢复，
6.0版本之后的redis采用RDB和AOF混合方式进行持久化，aof仅记录rbd快照之后的写命令

## 主从复制机制

1. 当slave连接上master，slave节点使用`psync`命令发送旧的主复制ID和目前处理的偏移量，通过这种方式master可以只发送所需的增量部分。
2. master接收到后，`bgsave` 生成rdb文件，期间缓存所有的新的写命令。
3. master将rdb文件发送给slave，slave将其保存到磁盘，然后加载到内存中，然后master将所有缓存命令发送给slave
5. 之后master执行的写命令都会直接同步给slave

**特点**: master提供写服务，slave提供读服务，降低了读写压力

不能保证高可用，master节点挂了就无法写服务，slave都挂了就无法提供读服务

## 集群模式有哪些

> sentinal模式和cluster模式

哨兵模式

1. 由多个哨兵对master节点和所有slave节点进行监控，同时哨兵节点之间也会**互相监控**，
每秒ping一次所有节点，如发现节点响应超时，会将其标记为**主观下线**，超过设定数量的哨兵对其标记主观下线，则该节点会被标记为**客观下线**，期间如果master返回响应会移除主观下线状态。

2. 如果是master节点被标记为客观下线，哨兵开始对其slave节点进行选举，选出新的master会修改他们的配置文件，之后其他slave节点分别向其发送同步请求，下线的master节点重启后为成为其slave。

当使用sentinal模式时，客户端不再直接连接redis，而是应当连接sentinal的

哨兵集群可以管理多个主从redis

cluster模式

> 哨兵模式保障了集群的高可用，但没有解决内存限制的问题，cluster则是其解决方案：将redis的数据根据一定的规则（hash slot）分配到多台机器

cluster可以说是sentinel和主从模式的结合，每个集群至少需要3个主数据库，再配一个从库的话，则需要6个实例。

特点：
- **多主多从，去中心化**：从节点作为备用，不提供服务
- **不支持同时处理多个key**，因为redis需要把key均匀的分布到各个节点上，并发量很高的情况下同时创建key-value会降低性能甚至导致不可测的行为
- **支持动态扩容**
- 主节点之间互相通信，互相选举，不在依赖sentienal

## 缓存雪崩、击穿、穿透

雪崩
```
缓存雪崩是指redis缓存大量同时失效，导致大量请求直接落到数据库

解决方案是，给还缓存设置过期时间是设置一个较小的随机值
```
缓存击穿
```
高热key失效

解决方案：
1. 如果业务允许设置key不失效
2. 使用互斥锁，同一时间只允许一个请求进入数据库层
```
缓存穿透
```
请求不存在的key

解决方案：
1. 对合法的请求进行过滤
2. 利用布隆过滤器进行识别
3. 缓存空结果，设置较短的过期时间 
```

## 大key问题
[大key问题](bigkey和hotkey.md)

## redis原子性的理解
    
1. 因为redis的每个命令都是单线程执行的，避免多线程的上下文切换和锁开销
2. 通过lua脚本实现多条命令执行的原子性

## 在集群模式下，Redis 的 Key 是如何寻址的？
redis 的key寻址用的是hash slot算法

插槽算法把整个数据库被分为**16384**个slot（槽），每个进入Redis的键值对，根据key进行散列，分配到这16384插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16 位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。

集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：

节点A负责0~5460号哈希槽
节点B负责5461~10922号哈希槽
节点C负责10923~16383号哈希槽


## 分布式寻址都有哪些算法？
分布式寻址算法由: hash算法、一致性hash算法、hash slot

## 一致性hash算法
 一致性hash算法，是将hash值组织成虚拟的圆环，整个空间按顺时针方向组成，将各个master节点（ip）进行hash，就可以计算出每个节点在hash环上的位置。
 来一个key计**首先**算出来的hash值，确定在环上的位置，从这个位置开始顺时针行走，遇到的第一个master节点就是key所在的位置。

 在一致性hash算法中，一个节点故障，受影响的数据仅在此节点到环空间前一个节点之间的数据。同理增加一个节点也是如此

 然而一致性hash算法的节点太少，会出现key分布不均导致缓存热点问题，为此一致性hash引入了虚拟节点，即对一个节点计算多个hash值，每个计算结果都放置一个虚拟节点，这样就实现了数据均匀分布，负载均衡。

## 使用Redis有哪些好处？

- 作为缓存层，大大提高读写性能，提高并发
- 丰富的数据类型，如list、set、zset、hash、json、bitmap、布隆过滤器、布谷鸟过滤器、topk等高效解决了很多常见场景问题
- 存储分布式session
- 持久化和自带集群模式，保证了高可用的

## Redis相比Memcached有哪些优势？

1. 数据类型丰富
2. 支持数据持久化
3. 自带集群模式解决方案，且配置简单


## MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？

1. 懒加载，在读取数据的时候进行缓存，并设置一个合适的过期时间
2. 内存淘汰规则设置成 `volitate-lfu`，即淘汰设置了过期时间的key中使用频率最低的

## 在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？
> 高并发场景下可以充分利用redis特性

## Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？
> 基础数据类型有：字符串、hash、list、set、zset、json

1. string 可以用来作为计数器，存储热点数据
2. hash 适合存储简单对象
3. list 可以用来做队列
4. set 适合进行集合操作，如计算交集、并集、差集
5. zset 适合做排行榜这类带排序功能的列表
6. json 适合存储层级较深的对象，操作对象的部分频繁的场景
7. 另外还有：布隆过滤器、布谷鸟过滤器、地理位置空间、bimap、hyperLogLog、topK等

## 为什么redis单线程却能支撑高并发？

1. 基于内存实现
2. io多路复用模型，允许单个线程处理多个并发连接
3. 单线程模型，避免上线问切换和锁的开销（命令放在寄存器队列中，由事件处理器顺序执行，保证原子性)
4. 精简的数据结构和高效的算法。
5. 虚拟内存机制

## 双写一致性
- 延迟双删
- 删除重试
- 去读binlong异步删除
- 提供人工强制同步功能

[双写一致性](redis和mysql双写一致性.md)

## redis与mecached对比

## 为什么redis6.0之后改用多线程
redis使用时几乎不存在cpu成为瓶颈的情况，它主要受限于内存和网络。

redis使用多线程，并非完成摒弃单线程，只是**使用多线程来处理数据的读写和协议解析，执行命令还是单线程**


## 安全的使用list

Redis的list经常被当作队列使用，左进右出，一般生产者使用lpush压入数据，消费者调用rpop取出数据。

但是可能会出现，执行后rpop后的任务失败，到时数据丢失。

方法一：**可以改用lrange+ltrim代替lpop**，在处理成功后再调用了ltrim，这样可以做到至少处理一次。本方法可能产生重复，需要保证幂等。另外普通使用lrange+ltrim还会限定只能有一个消费者，如果是多消费者，则还需结合eval命令，借助lua来实现多消息。

方法二：待处理的任务先存储的数据库中，分成两个线程进行处理，一个线程负责将未完成的任务写入list，另一个线程负责消费，消费成功修改任务状态。


